# -*- coding: utf-8 -*-
"""decision_tree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v9GI3mT94_c3vNp42UbyoWjTM-WErELv
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
import re
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

def main_model():
    data = pd.read_csv('112rows.csv')

    data.columns = data.columns.str.strip()

    data.columns

    data = data.drop(['What active ingredient (or ingredients) are present for the concern?', 'If there is fragrance in the product, is it impacting the rating? (put N/A if no fragrance)'], axis=1)

    data['Skin type'].unique()

    data['Sensitivity'].unique()

    data['Fragrance Preference'].unique()

    data['Degree of Concern'].unique()

    data['Concern'].unique()

    data['Rating (Not recommended, OK, Great, Excellent)'].unique()

    rating_map = {
        'Great': 'Great',
        ' Excellent': 'Excellent',
        'Excellent ': 'Excellent',
        'Excellent': 'Excellent',
        ' Great': 'Great',
        'Ok': 'Ok',
        'Not recommended': 'Not recommended',
        'Not recommended ': 'Not recommended'
    }

    data['Rating (Not recommended, OK, Great, Excellent)'] = data['Rating (Not recommended, OK, Great, Excellent)'].str.strip().map(rating_map)

    print(data['Rating (Not recommended, OK, Great, Excellent)'].unique())

    data.columns

    data.to_csv("cleaned_112.csv", index=False)

    data=pd.read_csv("cleaned_112.csv")

    data.columns

    k=data['Product Link'].unique()

    len(k)

    df= pd.read_csv("allfixed.csv")

    data['Product Link Copy'] = data['Product Link']  # Copy the column before setting it as index
    df['Product Link Copy'] = df['Product Link']

    df.set_index('Product Link', inplace=True)
    data.set_index('Product Link', inplace=True)

    matching_links = data.index.intersection(df.index)
    print(f'Number of matching product links: {len(matching_links)}')

    data.loc[matching_links, 'Skin_Type_P'] = df.loc[matching_links, 'Skin Type']
    data.loc[matching_links, 'Skincare_Concerns_P'] = df.loc[matching_links, 'Skincare Concerns']
    data.loc[matching_links, 'Fragrance_Free_P'] = df.loc[matching_links, 'Fragrance Free']

    data.columns

    data.columns

    data['Skin type'].unique()

    data['Concern'].unique()

    data['Sensitivity'].unique()

    data['Fragrance Preference'].unique()

    data['Degree of Concern'].unique()

    data['Rating (Not recommended, OK, Great, Excellent)'].unique()

    data['Skin_Type_P'].unique()

    def clean_skin_type(s):
        s = s.lower().replace("and", ",").replace("\n", "").replace("[", "").replace("]", "").replace("'", "").strip()
        return ','.join(sorted(set(s.replace(",", " ").split())))

    data['Cleaned_Skin_Type'] = data['Skin_Type_P'].apply(clean_skin_type)

    # skin_type_dummies = data['Cleaned_Skin_Type'].str.get_dummies(sep=',')
    # result = pd.concat([data, skin_type_dummies], axis=1)

    data

    data['Cleaned_Skin_Type'].unique()

    data['Cleaned_Skin_Type'].isnull().sum()

    data['Skincare_Concerns_P'].unique()



    def clean_skincare_concerns(s):
        concern_map = {
            r'\bdryness\b': 'Dryness',
            r'\boiliness\b': 'Oiliness',
            r'fine\s+lines\s*(and)?\s*wrinkles|loss\s+of\s+firmness\s*(and)?\s*elasticity': 'Aging',
            r'\bacne\b': 'Acne',
            r'\bdark\s+spots\b': 'Dark Spots'
        }

        s = s.lower().replace("\n", " ").replace("[", " ").replace("]", " ").replace("'", " ").replace(",", " ").strip()
        concerns = set()

        for pattern, concern in concern_map.items():
            if re.search(pattern, s):
                concerns.add(concern)

        return ', '.join(sorted(concerns))

    data['Cleaned_Skincare_Concerns'] = data['Skincare_Concerns_P'].apply(clean_skincare_concerns)

    data['Cleaned_Skincare_Concerns'].unique()

    data['Cleaned_Skincare_Concerns'].isnull().sum()

    data['Fragrance_Free_P'].unique()

    data.to_csv('combined_features.csv', index=False)

    data.columns

    data.drop(['Skin_Type_P','Skincare_Concerns_P'], axis=1, inplace=True)

    data.to_csv('features.csv', index=False)


    df=pd.read_csv("features.csv")

    df.columns

    def expand_multilabel_col(df, column_name, prefix):
        dummies = df[column_name].str.get_dummies(sep=',')
        dummies.columns = [prefix + col.strip() for col in dummies.columns]  # Add prefix and strip spaces
        return dummies

    categorical_columns = ['Skin type', 'Concern', 'Sensitivity', 'Fragrance Preference', 'Degree of Concern', 'Fragrance_Free_P']
    one_hot_encoded_data = pd.get_dummies(df[categorical_columns])

    one_hot_cleaned_skin_type = expand_multilabel_col(df, 'Cleaned_Skin_Type', 'SkinType_')
    one_hot_cleaned_skincare_concerns = expand_multilabel_col(df, 'Cleaned_Skincare_Concerns', 'Skincare_')

    temp_encoded_df = pd.concat([one_hot_encoded_data, one_hot_cleaned_skin_type, one_hot_cleaned_skincare_concerns], axis=1)

    final_encoded_df = temp_encoded_df.groupby(temp_encoded_df.columns, axis=1).sum()

    final_encoded_df['Rating'] = df['Rating (Not recommended, OK, Great, Excellent)']
    final_encoded_df['Product Link'] = df['Product Link Copy'].astype('category')

    print(final_encoded_df.info())
    final_encoded_df.head()

    final_encoded_df.head()

    train_encoded_df=final_encoded_df.copy()

    train_encoded_df.drop('SkinType_sensitive', axis=1, inplace=True)

    train_encoded_df.to_csv('onehot_train.csv', index=False)

    train_encoded_df.columns

    rating_mapping = {'Not recommended': 0, 'Ok': 1, 'Great': 2, 'Excellent': 3}
    train_encoded_df['Rating_Numeric'] = train_encoded_df['Rating'].map(rating_mapping)

    correlation_with_rating = train_encoded_df.corr(numeric_only=True)['Rating_Numeric'].sort_values(ascending=False)

    print("Correlation of each feature with the 'Rating_Numeric' column:")
    print(correlation_with_rating)


    train_data = pd.read_csv('features.csv')

    train_data
    test_data = pd.read_csv('test set.csv')

    train_data=pd.read_csv("features.csv")

    train_data.columns

    test_data.columns

    train_data = train_data[~train_data.index.duplicated(keep='first')]
    test_data = test_data[~test_data.index.duplicated(keep='first')]

    matching_links = test_data.index.intersection(train_data.index)
    print(f'Number of matching product links: {len(matching_links)}')

    test_data.loc[matching_links, 'Fragrance_Free_P'] = train_data.loc[matching_links, 'Fragrance_Free_P']
    test_data.loc[matching_links, 'Cleaned_Skin_Type'] = train_data.loc[matching_links, 'Cleaned_Skin_Type']
    test_data.loc[matching_links, 'Cleaned_Skincare_Concerns'] = train_data.loc[matching_links, 'Cleaned_Skincare_Concerns']

    test_data

    test_data.columns

    test_data.to_csv('test.csv', index=False)

    def expand_multilabel_col(df, column_name, prefix):
        dummies = df[column_name].str.get_dummies(sep=',')
        dummies.columns = [prefix + col.strip() for col in dummies.columns]  # Add prefix and strip spaces
        return dummies

    categorical_columns = ['Skin type', 'Concern', 'Sensitivity', 'Fragrance Preference', 'Degree of Concern', 'Fragrance_Free_P']
    one_hot_encoded_data = pd.get_dummies(test_data[categorical_columns])

    one_hot_cleaned_skin_type = expand_multilabel_col(test_data, 'Cleaned_Skin_Type', 'SkinType_')
    one_hot_cleaned_skincare_concerns = expand_multilabel_col(test_data, 'Cleaned_Skincare_Concerns', 'Skincare_')

    temp_encoded_df = pd.concat([one_hot_encoded_data, one_hot_cleaned_skin_type, one_hot_cleaned_skincare_concerns], axis=1)

    test_encoded_df = temp_encoded_df.groupby(temp_encoded_df.columns, axis=1).sum()

    test_encoded_df['Rating'] = test_data['Rating']
    test_encoded_df['Product Link'] = test_data['Product Link'].astype('category')

    print(test_encoded_df.info())
    test_encoded_df.head()

    test_encoded_df = pd.read_csv('backend_user_data.csv')
    print(test_encoded_df.columns)  # Print the available columns to verify if 'SkinType_sensitive' exists

    # Only drop the column if it exists
    if 'SkinType_sensitive' in test_encoded_df.columns:
        test_encoded_df.drop('SkinType_sensitive', axis=1, inplace=True)
        print("Column 'SkinType_sensitive' dropped.")
    else:
        print("Column 'SkinType_sensitive' not found in the DataFrame.")

    test_encoded_df.head()



    rating_mapping = {'Not recommended': 0, 'Ok': 1, 'Great': 2, 'Excellent': 3}
    test_encoded_df['Rating_Numeric'] = test_encoded_df['Rating'].map(rating_mapping)

    test_encoded_df.to_csv('onehot_test.csv', index=False)

    test_encoded_df.columns

    label_encoder = LabelEncoder()

    train_encoded_df['Product Link Encoded'] = label_encoder.fit_transform(train_encoded_df['Product Link'])
    test_encoded_df['Product Link Encoded'] = label_encoder.transform(test_encoded_df['Product Link'])

    X_train = train_encoded_df.drop(['Rating', 'Product Link', 'Rating_Numeric'], axis=1)
    y_train = train_encoded_df['Rating_Numeric']
    X_test = test_encoded_df.drop(['Rating', 'Product Link', 'Rating_Numeric'], axis=1)
    y_test = test_encoded_df['Rating_Numeric']

    model = DecisionTreeClassifier(random_state=42)

    model.fit(X_train, y_train)

    train_predictions = model.predict(X_train)
    train_accuracy = accuracy_score(y_train, train_predictions)
    print(f"Training Accuracy: {train_accuracy:.2f}")

    test_predictions = model.predict(X_test)
    return test_predictions
    

main_model()